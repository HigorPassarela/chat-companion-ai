import os
import logging
from flask import Flask, request, jsonify, Response, stream_with_context
from flask_cors import CORS
from werkzeug.utils import secure_filename
import requests
import json

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("chat.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)

UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'doc', 'docx', 'csv', 'json'}
MAX_FILE_SIZE = 16 * 1024 * 1024 

if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE

logger.info("[OK] Usando codellama:7b via Ollama")

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route("/ping", methods=["GET"])
def ping():
    logger.info("[PING] Requisicao de teste recebida")
    return jsonify({"status": "ok", "message": "Backend esta funcionando!"})

@app.route("/upload", methods=["POST"])
def upload_file():
    try:
        logger.info("[UPLOAD] Requisicao de upload recebida")
        
        if 'file' not in request.files:
            logger.warning("[WARN] Nenhum arquivo enviado")
            return jsonify({"erro": "Nenhum arquivo enviado"}), 400
        
        file = request.files['file']
        
        if file.filename == '':
            logger.warning("[WARN] Nome de arquivo vazio")
            return jsonify({"erro": "Nome de arquivo vazio"}), 400
        
        if not allowed_file(file.filename):
            logger.warning(f"[WARN] Tipo de arquivo nao permitido: {file.filename}")
            return jsonify({"erro": "Tipo de arquivo nao permitido"}), 400
        
        filename = secure_filename(file.filename)
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(filepath)
        
        logger.info(f"[OK] Arquivo salvo: {filepath}")
        
        file_content = ""
        try:
            if filename.endswith('.txt'):
                with open(filepath, 'r', encoding='utf-8') as f:
                    file_content = f.read()
                logger.info(f"[OK] Conteudo lido: {len(file_content)} caracteres")
        except Exception as e:
            logger.warning(f"[WARN] Nao foi possivel ler conteudo: {str(e)}")
        
        return jsonify({
            "sucesso": True,
            "filename": filename,
            "filepath": filepath,
            "size": os.path.getsize(filepath),
            "content": file_content[:500] if file_content else None  
        })
    
    except Exception as e:
        logger.error(f"[ERROR] Erro no upload: {str(e)}", exc_info=True)
        return jsonify({"erro": str(e)}), 500

@app.route("/chat-with-file", methods=["POST"])
def chat_with_file():
    try:
        data = request.json
        pergunta = data.get("pergunta")
        file_content = data.get("file_content", "")
        
        logger.info(f"[IN] Pergunta com arquivo recebida: {pergunta}")
        
        if not pergunta:
            return jsonify({"erro": "Pergunta vazia"}), 400
        
        
        if file_content:
            prompt_completo = f"""Baseado no seguinte conteúdo de arquivo:

---
{file_content[:2000]}  # limitar a 2000 caracteres
---

Pergunta do usuário: {pergunta}

Responda em português brasileiro:"""
        else:
            prompt_completo = f"Responda em português: {pergunta}"
        
        return Response(
            stream_with_context(chat_pergunta_stream(prompt_completo)),
            mimetype='text/event-stream',
            headers={
                'Cache-Control': 'no-cache',
                'X-Accel-Buffering': 'no'
            }
        )
    
    except Exception as e:
        logger.error(f"[ERROR] {str(e)}", exc_info=True)
        return jsonify({"erro": str(e)}), 500

@app.route("/chat", methods=["POST"])
def chat():
    try:
        logger.info(f"[OK] Requisicao recebida: {request.json}")
        
        data = request.json
        pergunta = data.get("pergunta")
        
        logger.info(f"[IN] Pergunta recebida: {pergunta}")
        
        if not pergunta:
            logger.warning("[WARN] Pergunta vazia recebida")
            return jsonify({"erro": "Pergunta nao pode estar vazia"}), 400
        
        return Response(
            stream_with_context(chat_pergunta_stream(pergunta)),
            mimetype='text/event-stream',
            headers={
                'Cache-Control': 'no-cache',
                'X-Accel-Buffering': 'no'
            }
        )
    
    except Exception as e:
        logger.error(f"[ERROR] Erro ao processar requisicao: {str(e)}", exc_info=True)
        return jsonify({"erro": str(e)}), 500

def chat_pergunta_stream(pergunta):
    try:
        logger.debug(f"[CALL] Enviando para codellama:7b: {pergunta[:100]}...")
        
        prompt_completo = f"""Você é um assistente que sempre responde em português brasileiro.

{pergunta}

Resposta:"""
        
        response = requests.post(
            "http://localhost:11434/api/generate",
            json={
                "model": "codellama:7b",
                "prompt": prompt_completo,
                "stream": True,
                "options": {
                    "num_predict": 500,
                    "temperature": 0.7,
                    "top_p": 0.9
                }
            },
            stream=True,
            timeout=500
        )
        
        if response.status_code != 200:
            error_msg = f"Erro do Ollama: {response.text}"
            logger.error(f"[ERROR] {error_msg}")
            yield f"data: {json.dumps({'error': error_msg})}\n\n"
            return
        
        resposta_completa = ""
        for line in response.iter_lines():
            if line:
                try:
                    chunk = json.loads(line)
                    
                    if "response" in chunk and chunk["response"]:
                        token = chunk["response"]
                        resposta_completa += token
                        yield f"data: {json.dumps({'token': token})}\n\n"
                    
                    if chunk.get("done", False):
                        logger.info(f"[OUT] Resposta completa enviada")
                        yield f"data: {json.dumps({'done': True})}\n\n"
                        break
                        
                except json.JSONDecodeError as e:
                    logger.warning(f"[WARN] Erro ao decodificar JSON: {e}")
                    continue
    
    except Exception as e:
        error_msg = str(e)
        logger.error(f"[ERROR] {error_msg}", exc_info=True)
        yield f"data: {json.dumps({'error': error_msg})}\n\n"

if __name__ == "__main__":
    logger.info("[START] Iniciando servidor Flask na porta 5000...")
    app.run(debug=True, port=5000, threaded=True)